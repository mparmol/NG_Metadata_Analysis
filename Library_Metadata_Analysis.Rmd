---
output: rmarkdown::github_document
---

# **NextGame project - Metadata Analysis** ![Stars](https://img.shields.io/github/stars/mparmol/NG_Steam_Library_Metadata)

```{r loadpackages, include=FALSE}
library(ggplot2)

#Here you can load your dataset

Input_file<-"Steam_Metadata_Full_marko_pakete.txt"

datos<-read.delim(Input_file,header = F)

```

## `r strsplit(strsplit(Input_file,"Full_")[[1]][2],"\\.")[[1]][1]` Steam Library data

· Number of listed Apps 

```{r}
dim(datos)[1]
```
· Total time to finish library

```{r}
paste(sum(as.numeric(datos[datos[,3]!="No time registered yet" & !is.na(datos[,3]),3])),"h")
paste(round(sum(as.numeric(datos[datos[,3]!="No time registered yet" & !is.na(datos[,3]),3]))/24/30/12,digits = 2),"years")
```

· Average time to finish a game

```{r}
paste(round(mean(as.numeric(datos[datos[,3]!="No time registered yet" & !is.na(datos[,3]),3])),digits = 2),"h")

ggplot(datos[datos[,3]!="No time registered yet" & !is.na(datos[,3]) & datos[,3]>0,], aes(x=factor(V3, level=seq(min(as.numeric(datos[datos[,3]!="No time registered yet" & !is.na(datos[,3]),3])),max(as.numeric(datos[datos[,3]!="No time registered yet" & !is.na(datos[,3]),3])),1)))) + geom_histogram(stat = "count") + theme_bw() + theme(axis.text.x = element_text(angle=90, hjust=1)) + ylab("Games count") + xlab("Time to finish")

```
· Average time to 100% complete a game

```{r}
paste(round(mean(as.numeric(datos[datos[,4]!="No time registered yet" & !is.na(datos[,4]),4])),digits = 2),"h")
```

· Total time to 100% complete library

```{r}
paste(sum(as.numeric(datos[datos[,4]!="No time registered yet" & !is.na(datos[,4]),4])),"h")
paste(round(sum(as.numeric(datos[datos[,4]!="No time registered yet" & !is.na(datos[,4]),4]))/24/30/12,digits = 2),"years")
```


## HowLongToBeat method accuracy 

We analyze the accuracy of the HowLongToBeat methodology. Each hit to the database is related to a similarity index. 

First we need to know the number of games to which we have found a result in the database when calling their name with the API. This data is analyzed from the "Full" metadata table.


```{r}
print(dim(datos[!is.na(datos$V3) &  !is.na(datos$V4),])[1])
```

From the total number we can see the similarity distribution.

```{r, warning=FALSE}
ggplot(datos,aes(V5)) + geom_bar()
```

Being the total number of exact matches (similarity = 1)

```{r}
print(dim(datos[datos$V5==1,])[1])
```

Focusing on the games that aren't similaryt=1 we can highlight the "problems". Lets focus on each case an their closest result

```{r}
datos[datos$V5<1,c(1,2,5)][1:20,]
```

So as we can see, most "problems" are derived from typos, such as ":" o romanic values

## Recomended and forbiden games for achivement collectors

If you are a completionist you would like to play games that are easy to 100% complete. This is not only the shorttest games, but the games that could be easily completed just playing (avoiding in the majority of cases farming/grinding games). The representation of the time to beat against the time t beat at 100% could shade lights on this question

```{r, warning=FALSE}
datos_lim<-datos[datos[,3]!="No time registered yet",] # We remove the entries with not time regisrered yet
datos_lim[,3]<-as.numeric(datos_lim[,3]) 
datos_lim[,4]<-as.numeric(datos_lim[,4])

datos_lim<-datos_lim[datos_lim[,3]>0,] # We remove the 0 hours game
datos_lim<-datos_lim[datos_lim[,4]>0,]

ggplot(datos_lim, aes(V4,V3,label=V1)) + geom_point() + theme_bw() + geom_text(hjust=0, vjust=0) + ylab("Tiempo pasartelo (h)") + xlab("Tiempo completarlo 100% (h)")
```

A lot of sport simulation games, concretely Football Manager games, and Aura Kingdom are the games that show the most biased distribution when comparing both parameters, based in farming and repetition. Football Manager games surround 1000h of game play to complete it at a 100%, while Aura Kingdom, a MMO, is up to 9000h to finish it. It is easy to think on these as farming related achievements that will take an insane amount of time.

But we can see much using this kind of approach, so we better create a index to save the games that are more biased according to the difference beeteen finished and 100% games

```{r}
datos_lim$time_index<-datos_lim$V4/datos_lim$V3

datos_lim <- datos_lim[order(as.factor(datos_lim$time_index),decreasing = T),]
datos_lim$V1 <- reorder(datos_lim$V1, -datos_lim$time_index)

#time_rel<-datos_lim[order(datos_lim$time_index,decreasing=TRUE),]

#ggplot(time_rel[1:5,],aes(V1,time_index)) + geom_bar()

ggplot(datos_lim[1:20,], aes(V1,time_index,label=V1)) + geom_bar(stat = "identity") + theme_bw() + theme(axis.text.x = element_text(angle=90, hjust=1))

```

The same way, we can take a look to the fastest game to complete, looking at game with the lowest index

```{r}
datos_lim <- datos_lim[order(as.factor(datos_lim$time_index),decreasing = F),]
datos_lim$V1 <- reorder(datos_lim$V1, -datos_lim$time_index)

#time_rel<-datos_lim[order(datos_lim$time_index,decreasing=TRUE),]

#ggplot(time_rel[1:5,],aes(V1,time_index)) + geom_bar()

#ggplot(datos_lim[1:30,], aes(V1,time_index,label=V1)) + geom_bar(stat = "identity") + theme_bw() + theme(axis.text.x = element_text(angle=90, hjust=1))

paste("Number of games that can be 100% achieved by finishing it:",length(na.omit(datos_lim[datos_lim$time_index==1,1])))

as.character(na.omit(datos_lim[datos_lim$time_index==1,1])[1:30])

```

We can order this information by user positive rating

```{r}
datos_lim <- datos_lim[(datos_lim[,12]+datos_lim[,13])>=100,]
datos_lim <- datos_lim[order(as.factor(round((datos_lim[,12]/(datos_lim[,12]+datos_lim[,13]))*100,digits=1)),decreasing = T),]
datos_lim$V1 <- reorder(datos_lim$V1, -datos_lim$time_index)

datos_lim$rating <- as.factor(round((datos_lim[,12]/(datos_lim[,12]+datos_lim[,13]))*100,digits=1))
#time_rel<-datos_lim[order(datos_lim$time_index,decreasing=TRUE),]

#ggplot(time_rel[1:5,],aes(V1,time_index)) + geom_bar()

#ggplot(datos_lim[1:30,], aes(V1,time_index,label=V1)) + geom_bar(stat = "identity") + theme_bw() + theme(axis.text.x = element_text(angle=90, hjust=1))

out<-datos_lim[datos_lim$time_index==1,][1:30,c(1,11,14,19,26)]
colnames(out)<-c("Name","Genre","Developer","Release date","Positive rating")
out
```

These are the best rated game to entirele complete in a single run

## Genre analysis

First we need to split de Genre column to create an abscence/presence table. The same for Tags

```{r}
#Genre

datos$V11<-gsub(", ",",",datos$V11)

genre_df<-data.frame(matrix(nrow = dim(datos)[1]))
genre_df[,1]<-datos$V1

genre_split <- strsplit(datos$V11, ",")

genre_split_c <- unique(unlist(genre_split))

for (genre_split_cs in genre_split_c) {
  genre_df[genre_split_cs] <- sapply(genre_split, function(x) genre_split_cs %in% x)
}

genre_df$total <- rowSums(genre_df[genre_split_c])

#Tags

datos$V16<-gsub(", ",",",datos$V16)

tags_df<-data.frame(matrix(nrow = dim(datos)[1]))
tags_df[,1]<-datos$V1

tags_split <- strsplit(datos$V16, ",")

tags_split_c <- na.omit(unique(unlist(tags_split)))

for (tags_split_cs in tags_split_c) {
  tags_df[tags_split_cs] <- sapply(tags_split, function(x) tags_split_cs %in% x)
}

tags_df$total <- rowSums(tags_df[tags_split_c])

```

Now we can explore the data and plot de proportion of each genre

```{r}
ggplot(genre_df, aes(x = "", y = total, fill = factor(total))) +
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  scale_fill_discrete(name = "Presencia de campos") +
  ggtitle("Gráfico de pastel de presencia de campos") +
  xlab("") +
  ylab("Presencia de campos") +
  theme_void()
```



If we remove these games we could focus on the next most biased games

```{r, warning=FALSE}
datos_lim<-datos_lim[!grepl("Football Manager",datos_lim[,1]) & datos_lim[,1]!="Aura Kingdom",]

ggplot(datos_lim, aes(V4,V3,label=V1)) + geom_point() + theme_bw() + geom_text(hjust=0, vjust=0) + ylab("Tiempo pasartelo (h)") + xlab("Tiempo completarlo 100% (h)")
```

Even after removing those games, there are still plenty of games biased to the 100% completion rate. Now we can see othe sport games, such as NBA and Our of the park games, in company with MMO titles like Black Desert, on the top of the figure. After removing them we can see other games. These games are the more time demanding game, for finishing and completion, but not the most biased games. To get the names of the most based game we should focus on the games that have a really low time to complete (less than 5h) but insane time for 100% finishing.

```{r,warning=FALSE}
datos_lim<-datos_lim[datos_lim$V3<=5,]

ggplot(datos_lim, aes(V4,V3,label=V1)) + geom_point() + theme_bw() + geom_text(hjust=0, vjust=0) + ylab("Tiempo pasartelo (h)") + xlab("Tiempo completarlo 100% (h)")
```

This representation is not the best option for lloking at the data, let's represent it as barplots

```{r,warning=FALSE}
datos_lim<-datos_lim[datos_lim$V3<=1,]

ggplot(datos_lim, aes(V3,V4,label=V1)) + geom_jitter(position = position_jitter(seed = 1)) + geom_text(position = position_jitter(seed = 1)) + theme_bw()
```
This way you can take a closer look at games that will only take an hour to finish, most of them Arcade games, but will take up to 80 hours to finish completely, in the case of King of Fighters '98 Ultimate Match Final Edition. (ESTO ES MEJOR HACER BoxPlot y mostrar solo los puntos que sean outlier...cómo?)

################################# Analyze Steam_library


datos<-read.delim("Steam_Library_Metadata_marko_pakete.txt",header = T)


###### N?mero de juegos, tiempo total de juego, tiempo medio de juego, conteo de generos, puntuaci?n media y desviaci?n, n?mero de juegos por develop y publisher

#Number of entries

print(dim(datos)[1])

# Time to finish library

datos_lim<-datos[datos[,3]!="No time registered yet" & !is.na(datos[,3]),]
datos_lim[,3]<-as.numeric(datos_lim[,3])
datos_lim[,4]<-as.numeric(datos_lim[,4])

datos_lim<-datos_lim[datos_lim[,3]>0,]
datos_lim<-datos_lim[datos_lim[,4]>0,]

print(paste0(((sum(datos_lim$V3)/24)/31)/12," years"))

# Time to COMPLETE library

datos_lim<-datos[datos[,4]!="No time registered yet" & !is.na(datos[,4]),]
datos_lim[,3]<-as.numeric(datos_lim[,3])
datos_lim[,4]<-as.numeric(datos_lim[,4])

datos_lim<-datos_lim[datos_lim[,3]>0,]
datos_lim<-datos_lim[datos_lim[,4]>0,]

print(paste0(((sum(datos_lim$V4)/24)/31)/12," years"))

######Tiempo medio

datos_lim<-datos[datos[,8]!="No time registered yet" & !is.na(datos[,8]),]
datos_lim[,8]<-as.numeric(datos_lim[,8])
datos_lim<-datos_lim[datos_lim[,8]>0,]

mean(datos_lim[,8])

######## Pensar c?mo representar valoraci?n de los juegos por compa??a y por a?o

factor(datos$V14)

heatmap(datos$V15,datos$V14)


####################

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
